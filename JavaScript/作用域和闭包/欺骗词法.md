# 欺骗词法

## 一、eval

`JavaScript` 中的 `eval` 接受一个字符串作为参数，将其中的内容视为存在于程序位置的代码。类似于使用程序生成代码并且运行，就好像代码本身就在那个位置一样。

在执行 `eval` 之后的代码时，引擎并不知道这段代码是动态插入生成的，并且对当前的词法作用域环境进行修改，只会按往常一样根据词法作用域进行查找。

例如：

```js
function foo(str, a) {
	eval(str);
	console.log(a);
}
var b = 2;
foo("var b = 3;", a);
```

由于 `eval(...)` 调用 `var b = 3;` ，导致在 `foo` 函数作用域中声明一个变量 `b` 并且赋值为 `3` ，导致遮蔽了外层全局作用域的变量 `b` ,从而改变输出 `3,2` 而不是正常状态的 `1,2` 。

`eval(...)` 实现了在**运行期修改书写期的词法作用域**。

> 在严格模式下，`eval()` 在运行时会有自己的词法作用域，从而无法修改所在的作用域。

```js
function foo(str) {
	"use strict";
	eval(str);
	console.log(a); // ReferenceError: a is not defined
}
foo("var a = 3;");
```

## 二、with

`with` 通常被当作重复引用同一个对象的多个属性的快捷方式。

例如：

```js
var obj = {
	a: 1,
	b: 2,
	c: 3,
}

// 单调乏味的重复 "obj" 
obj.a = 2;
obj.b = 3;
obj.c = 4;

// 简单的快捷方式 
with (obj) 
{ 
	a = 3; 
	b = 4; 
	c = 5; 
}
```

但实际上不仅仅会为了方便访问对象属性，也会造成部分变量的泄漏。

```js
function foo(obj) {
    with (obj) {         
    	a = 2;     
    } 
} 
 
var o1 = {     
	a: 3 
}; 
 
var o2 = {     
	b: 3 
}; 
 
foo( o1 ); 
console.log( o1.a ); // 2 
 
foo( o2 ); 
console.log( o2.a ); // undefined 
console.log( a ); // 2—— a被泄漏到全局作用域上
```

`with` 块的内部，会进行一个 `LSH` 引用，生成一个变量放到 `with` 所在的作用域。它会将一个对象视为一个词法作用域。当前词法作用域没有所需要的标识符的时候，会进行 `LHS` 标识符查找，直到在某一个作用域找到标识符为止，或者在全局作用域创建一个。

## 三、性能

`JavaScript` 引擎会在编译阶段进行性能优化，有些优化依赖于代码的词法静态分析，预先确定函数和变量定义的位置，才能快速的找到标识符。

当代码种出现 `eval` 和 `with` 的时候，会干扰引擎进行判断，无法知道作用域进行了何种修改，或者创建了何种作用域，因此引擎会完全不做任何优化，导致运行效率降低。
