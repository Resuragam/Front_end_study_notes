# 欺骗词法

## 一、eval

`JavaScript` 中的 `eval` 接受一个字符串作为参数，将其中的内容视为存在于程序位置的代码。类似于使用程序生成代码并且运行，就好像代码本身就在那个位置一样。

在执行 `eval` 之后的代码时，引擎并不知道这段代码是动态插入生成的，并且对当前的词法作用域环境进行修改，只会按往常一样根据词法作用域进行查找。

例如：

```js
function foo(str, a) {
	eval(str);
	console.log(a);
}
var b = 2;
foo("var b = 3;", a);
```

由于 `eval(...)` 调用 `var b = 3;` ，导致在 `foo` 函数作用域中声明一个变量 `b` 并且赋值为 `3` ，导致遮蔽了外层全局作用域的变量 `b` ,从而改变输出 `3,2` 而不是正常状态的 `1,2` 。

`eval(...)` 实现了在**运行期修改书写期的词法作用域**。

> 在严格模式下，`eval()` 在运行时会有自己的词法作用域，从而无法修改所在的作用域。

```js
function foo(str) {
	"use strict";
	eval(str);
	console.log(a); // ReferenceError: a is not defined
}
foo("var a = 3;");
```

## 二、with

## 三、性能
