## CSS基础

### 1. CSS选择器及其优先级

| 选择器         | 格式           | 优先级权重 |
| -------------- | -------------- | ---------- |
| id选择器       | #id          | 100        |
| 类选择器       | .className     | 10         |
| 属性选择器     | a[ref = 'eee'] | 10         |
| 伪类选择器     | li:last-child  | 10         |
| 标签选择器     | div            | 1          |
| 伪元素选择器   | li:after       | 1          |
| 相邻兄弟选择器 | h1 + p         | 0          |
| 子元素选择器   | ul > li        | 0          |
| 后代选择器     | li a           | 0          |
| 通配符选择器   | *              | 0          |

对于选择器**优先级：**
* 标签选择器、伪元素选择器：1
* 类选择器，属性选择器，伪类选择器：10
* `id`选择器：100
* 内联样式：1000

**注意事项：**
* !important声明的样式优先级最高；
* 如果优先级相同，则最后出现的样式生效；
* 继承的样式优先级最低；
* 通用选择器，后代选择器，子元素选择器和相邻兄弟选择器的优先级权重为0；
* 样式来源不同时，优先级顺序为：内联样式 > 内部样式 > 外部样式 > 浏览器用户自定义样式 > 浏览器默认样式；

### 2. 说说你对盒子模型的理解

#### 盒子模型是什么？

一个盒子由四个部分组成：`content`，`padding`，`margin`，`border`。

* `border`，盒子边框，围绕盒子的内边距的一条或者多条线。
* `padding`，即内边距，清除内容周围的区域，内边距是透明的，受到盒子`background`属性影响。
* `margin`，即外边距，元素外创建额外的空白。

在`CSS`中，盒子模型分成：

* **W3C盒子模型**
* **IE怪异盒子模型**

默认情况下，盒子模型是`W3C`盒子模型。

#### 标准盒子模型

![img](https://static.vue-js.com/c0e1d2e0-8f9b-11eb-85f6-6fac77c0c9b3.png)

从上图可知：

* 盒子总宽度 = `width + padding + border + margin`。
* 盒子总高度 = `height + padding + border + margin`。

也就是说，标准盒子模型的`width/height`只是包括内容宽度和高度，没有包括`padding`，`margin`，`border`。

#### IE盒子模型

![img](https://static.vue-js.com/cfbb3ef0-8f9b-11eb-ab90-d9ae814b240d.png)

从上图可以看到：

- 盒子总宽度 = `width + margin`。
- 盒子总高度 = `height + margin`。

也就是，`width/height` 包含了 `padding `和 `border `值。

#### Box-sizing

`box-sizing`可以设置三个属性：

* **content-box**：默认属性，设置为W3C盒模型。
* **border-box**：设置为IE盒模型。
* **inherit**：继承父元素盒模型的值。

### 3. em/px/rem/vh/vw 这些单位有什么区别

* `px`，即像素，表示显示屏小点，常用的绝对长度单位。
* `em`，表示相对长度单位。相对于当前对象文本的字体大小，会继承父元素的字体大小。默认相对于浏览器默认字体尺寸（16px）。
* `rem`，表示相对长度单位。相对于`html`元素的文本字体大小。
* `vh`，根据窗口的宽度，分为100份，即浏览器的可视区域和移动端的布局视口。
* `vw`，根据窗口的高度，分为100份，即浏览器的可视区域和移动端的布局视口。
* `%`，百分比单位一般是相对于父元素的大小。

### 4. CSS中，有哪些方式可以隐藏页面元素？有什么区别?

**display: none**

设置元素的`display`为`none`，可以隐藏该元素。

* 元素不可见。
* 元素不占据空间，会引发页面的回流与重绘。
* 自身的事件无法触发事件。

**visibility: hidden**

设置元素的`visibility`为`hidden`，可以隐藏该元素。

* 元素不可见。
* 元素会占据空间，因此不会引发页面的回流，但是元素不可见，会引发重绘。
* 自身的事件无法触发事件。

**opacity: 0**

`opacity`属性是设置元素的透明度，将透明度设置为0，元素在用户的视野是隐藏的。

* 改变元素的透明度，元素不可见。
* 元素会占据空间布局，不引发页面的回流，一般情况下会引发页面的重绘。
* 自身的事件可以触发。

**总结：**

* **display:none**会让元素从渲染树上消失，渲染不占据空间。**visibility:hidden**不会从渲染树上消失，渲染会占据空间，只是内容不可见。
* **display:none**不是继承属性，子元素会跟着父元素一起在渲染树上消失，通过修改子元素属性也无法显示。**visibility:hidden**是继承属性，子元素继承元素的`hidden`，通过设置`visibility:visible`可以让子孙节点显示。
* 修改常规文档流中元素的 `display` 通常会造成文档的重排，但是修改`visibility`属性只会造成本元素的重绘。

###  5. display的属性值及其作用

| 属性值       | 作用                                           |
| ------------ | ---------------------------------------------- |
| none         | 元素不显示，从渲染树中消失。                   |
| block        | 设置为块类型，可以设置宽高。                   |
| inline       | 行内元素类型，不可以设置宽高。                 |
| inline-block | 行内块类型，默认高度为内容高度，可以设置宽高。 |
| list-item    | 像块类型元素一样显示，并添加样式列表标记。     |
| table        | 块级表格类型。                                 |
| inherit      | 继承父元素类型。                               |

### 6. display的block、inline和inline-block的区别

* **block**：块级元素，可以设置宽和高，元素会独占一行，`margin`和`padding`属性均有效。
* **inline**：行内元素，不可以设置宽和高，元素不会独占一行，水平方向的`margin`和`padding`属性均有效。
* **inline-block**：将对象设置为`inline`对象，但对象的内容作为`block`对象呈现，之后的内联对象会被排列在同一行内。

### 7. link和@import的区别

两者都是引入CSS的方式，区别如下：

* **link**是`XHTML`标签，除了可以加载`CSS`之外，还可以记载`RSS`。**@import**只能加载`CSS`。
* **link**在加载页面时同时进行加载，但是**@import**会等到页面加载完毕后在进行加载。
* **link**无兼容是问题，而**@import**是`CSS2.1`提出来的，存在兼容性问题。
* **link**可以通过控制`DOM`，插入`link`标签改变样式，而**@import**不可以。

### 8. **伪元素和伪类的区别和作用？**

* 伪元素是在内容元素的前后插入额外的元素或者样式，但是这些元素或者样式不会再文档当中体现。它们只会在外部进行展示，在文档中无法查找，因此被称为“伪元素”。
* 伪类是将特殊的效果添加到特定的选择器上面。它是往已有元素上面添加类别，不会产生新的元素。

**总结**：伪类是通过元素选择器上加入伪类实现特殊效果，伪元素是对元素的操作进行改变。

### 9. CSS3中有哪些新特性

### 10. 对CSSSprites 的理解

将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 `background-image`，`background-repeat`，`background-position` 的组合进行背景定位。

**优点：**

* 利用`CSS Sprites`能很好地减少网页的http请求，从而大大的提高页面的性能。
* 减少图片的字节，多张图片合并成一张图片的字节大小要小于一张图片。

**缺点：**

* 图片合成比较麻烦。
* 如果需要删除增加某一张图片，需要改变相应的布局，维护会比较困难。

### 11. CSS预处理器/后处理器是什么？为什么要使用它们？

**预处理器：**如：`less`，`sass`，用来预编译`sass`或者`less`，增加了`css`代码的复用性。层级，`mixin`， 变量，循环， 函数等对编写以及开发UI组件都极为方便。

**后处理器，** 如： `postCss`，通常是在完成的样式表中根据`css`规范处理`css`，让其更加有效。目前最常做的是给`css`属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。

`CSS`预处理器为`CSS`增加一些编程的特性，无需考虑浏览器的兼容问题，可以在`CSS`中使用变量，函数等一些在编程语言中才有的特性。可以让`css`更加的简洁，增加适应性以及可读性，可维护性等。

使用原因：

* 结构清晰，便于拓展。
* 可以轻松实现样式多重继承。