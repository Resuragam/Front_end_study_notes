Vue.js 的一个核心思想就是**数据驱动**。所谓数据驱动，是指视图由数据驱动生成的，我们对于视图的修改，不会直接操作 DOM ，而是通过修改数据。它相比我们传统的前端开发，如使用 jQuery 等前端库直接修改 DOM ，大大简化了代码量。特别是当交互复杂时，只需要关心数据的修改会让代码的逻辑变得更加清晰，因为 DOM 成为了 数据的映射，我们所有的逻辑都是对数据的修改，而不需要触碰 DOM ，这样的代码是利用维护的。

```ad-example
在 Vue.js 中，可以采用简洁的模板语法来声明式的将数据渲染为 DOM ：
~~~html
<div id="app">
	{{ message }}
</div>
~~~


~~~javascript
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
~~~
```

最终上述代码会在页面渲染出 `Hello Vue` 。下面我们将主要对 Vue 的模板和数据是如何渲染成最终的 DOM 。


## Vue构造函数
---
从入口代码进行分析，我们先来分析 `new Vue` 背后发生了哪些事情。我们都知道，在JavaScript 中调用 `new` 关键词表示实例化一个对象，而 `Vue` 其实是一个类，类在JavaScript中通过 `Function` 来实现，在源码中, 在 `src/core/instance/index.js` 中。

```js
function Vue(options) {  
  if (__DEV__ && !(this instanceof Vue)) {  
    warn('Vue is a constructor and should be called with the `new` keyword')  
  }  
  this._init(options)  
}
```

可以看到 `Vue` 只能被 `new` 关键词初始化，然后会调用 `this.init` 方法，该方法在 `src/core/instance/init.js` 中定义。

```js
export function initMixin(Vue: typeof Component) {  
  Vue.prototype._init = function (options?: Record<string, any>) {  
    const vm: Component = this  
    // a uid  
    vm._uid = uid++  
  
    let startTag, endTag  
    /* istanbul ignore if */  
    if (__DEV__ && config.performance && mark) {  
      startTag = `vue-perf-start:${vm._uid}`  
      endTag = `vue-perf-end:${vm._uid}`  
      mark(startTag)  
    }  
  
    // a flag to mark this as a Vue instance without having to do instanceof  
    // check    vm._isVue = true  
    // avoid instances from being observed  
    vm.__v_skip = true  
    // effect scope  
    vm._scope = new EffectScope(true /* detached */)  
    vm._scope._vm = true  
    // merge options  
    if (options && options._isComponent) {  
      // 优化内部组件实例  
      // 因为动态选项合并很慢，而且没有一个  
      // 内部组件实例需要特殊处理  
      // initInternalComponent 初始化内部组件  
      initInternalComponent(vm, options as any)  
    } else {  
      vm.$options = mergeOptions(  
        resolveConstructorOptions(vm.constructor as any),  
        options || {},  
        vm  
      )  
    }  
    /* istanbul ignore else */  
    if (__DEV__) {  
      initProxy(vm)  
    } else {  
      vm._renderProxy = vm  
    }  
    // expose real self  
    vm._self = vm  
    initLifecycle(vm) // 初始化生命周期  
    initEvents(vm) // 初始化事件  
    initRender(vm) // 初始化渲染  
    callHook(vm, 'beforeCreate', undefined, false /* setContext */) // 执行beforeCreate钩子函数  
    initInjections(vm) // resolve injections before data/props // 在数据或者props初始化前进行依赖注入  
    initState(vm) // 初始化状态  
    initProvide(vm) // resolve provide after data/props // 在数据或者props初始化前进行依赖解决  
    callHook(vm, 'created') // 执行create钩子函数  
  
    /* istanbul ignore if */  
    if (__DEV__ && config.performance && mark) {  
      vm._name = formatComponentName(vm, false)  
      mark(endTag)  
      measure(`vue ${vm._name} init`, startTag, endTag)  
    }  
  
    if (vm.$options.el) {  
      vm.$mount(vm.$options.el)  
    }  
  }  
}
```

Vue 初始化主要进行如下几件事情：

* 合并配置 `mergeOptions` 。
* 初始化生命周期 `initLifecycle` 。
* 初始化事件中心 `initEvents` 。
* 初始化渲染 `initRender` 。
* 初始化 `data` 、`props` 、`computed` 、`watcher` 等。

### 总结
---
Vue 的初始化逻辑将不同的功能逻辑进行拆分成单独的函数进行初始化，让主线逻辑更加清晰。

```js
if (vm.$options.el) {  
    vm.$mount(vm.$options.el)  
} 
```

Vue 进行初始化的最后，会检测是否有 `el` 属性，如果有，会调用 `vm.$mount` 方法挂载 `vm` ，挂载的目标是吧模板渲染成最终的 DOM ，接下来对 Vue 的挂载过程进行分析。

```ad-question
`new` 关键词的作用？
```


## Vue 实例挂载的实现
---






