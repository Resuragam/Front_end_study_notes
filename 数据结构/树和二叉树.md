```ad-note
title: Links
* [树基础 | OI-wiki](https://oi-wiki.org/graph/tree-basic/)
```

## 树的基本概念

* **父亲（parent node）**：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。 根结点没有父结点。
- **祖先（ancestor）**：一个结点到根结点的路径上，除了它本身外的结点。根结点的祖先集合为空。
- **子结点（child node）**：如果 `u` 是 `v` 的父亲，那么 `v` 是 `u` 的子结点。子结点的顺序一般不加以区分，二叉树是一个例外。
- **结点的深度（depth）**：到根结点的路径上的边数。
- **树的高度（height）**：所有结点的深度的最大值。
- **兄弟（sibling）**：同一个父亲的多个子结点互为兄弟。
- **后代（descendant）**：子结点和子结点的后代。或者理解成：如果是的祖先，那么是的后代。

![[树的基本结构.png]]

-   **完全二叉树（complete binary tree）**：只有最下面两层结点的度数可以小于 2，且最下面一层的结点都集中在该层最左边的连续位置上。

![[完全二叉树.png]]

-   **完美二叉树（perfect binary tree）**：所有叶结点的深度均相同的二叉树称为完美二叉树。

![[完美二叉树.png]]


## 二叉树的创建
---
二叉树🌲的基本数据结构定义：

```c++
struct TreeNode {  
    TreeNode *left;  
    TreeNode *right;  
    int value;  
};
```

举个🌰:

```ad-example
根据前序遍历创建二叉树
```cpp
// 前序构建树  
struct TreeNode* CreatTree(char* str, int* pi)  
{  
    if(str[* pi] == '#') {  
        (*pi) ++;  
        return NULL;  
    }  
    struct TreeNode* root = (struct TreeNode*)malloc(sizeof(struct TreeNode));  
    // 前序遍历递归  
    root -> val = str[(*pi)++];  
    root -> left = CreatTree(str, pi);  
    root -> right = CreatTree(str, pi);  
    return root;  
}
```


## 二叉树的遍历
---
### 前序遍历

二叉树的前序遍历是指先遍历根结点，再遍历左结点，最后遍历右结点。

举个🌰:

```ad-example
根据前序遍历输出二叉树
```cpp
// 前序输出树  
void preOrder(struct TreeNode* root)  
{  
    if(root == NULL)  
        return;  
    printf("%c ", root->val);  
    preOrder(root->left);  
    preOrder(root->right);  
}
```
