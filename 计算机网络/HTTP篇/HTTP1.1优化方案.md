我们可以从三种优化方案来优化 HTTP/1.1 协议：

* **尽量避免发送 HTTP 请求**;
* **在需要发送 HTTP 请求，考虑如何减少请求次数**；
* **减少服务器的 HTTP 响应的数据大小**;

下面，就针对这三种思路具体看看有哪些优化方法。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BC%98%E5%8C%96http1.1%E6%8F%90%E7%BA%B2.png)


## 如何避免发送 HTTP 请求？
---
对于一些重复的 HTTP 请求，比如每次得到的数据都是一样的，我们可以把这个「请求-响应」的数据都**缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。

所以，避免发送 HTTP 请求的方法就是通过缓存技术， HTTP 协议的头部又不少针对缓存的字段。

*那么缓存如何实现？*

客户端会把第一次请求和响应的数据保存在本地磁盘上面，其中将请求的 URL 作为 key, 而响应作为 value，两者形成映射关系。

这样后续发起相同的请求，就可以先在本地磁盘通过 key 查找对应的 value，也就得到了响应，如果找到了，就直接从本地读取该响应。毋庸置疑，读取本地磁盘的速度肯定比网络快得多，如下图：

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE.png)


*如果缓存的相应不是最新的，该如何解决？*

在服务器发送 HTTP 响应时，会估算一个过期时间，并把这个信息放到响应头部中，这样子客户端查看响应的头部信息时，一旦发现缓存的响应是过期的，则会重新发送网络请求。

客户端会重新发送网络请求，在请求的 `If-None-Match` 头部加上第一请求响应的 `Etag` 值，
这个值用来帮助服务器控制缓存验证，会进行比较。

```ad-question
`Etag` 值如何生成的？
```

如果不同，则说明客户端缓存的资源没有价值，服务器会返回最新的资源。

如果相同，说明客户端的缓存有效可以继续使用，那么服务器会返回不含有响应体的 `304 Not Modified` 响应，告诉客户端缓存文件仍然有效，这样子就可以减少网络传输中的时延。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E7%BC%93%E5%AD%98etag.png)


## 如何减少 HTTP 请求次数？
---
减少发送 HTTP 请求次数可以从以下 3 个方面入手：

* **减少重定向的请求次数**；
* **合并请求**；
* **延迟发送请求**；

### 减少重定向请求次数

**重定向请求**是指服务器上的资源可能因为迁移、维护等原因从 url1 移至 url2 后，客户端并不知情，他还是继续请求 url1，此时服务器不能粗暴地返回错误，而是通过 `302` 状态码和 `Location` 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再次向 url2 发送请求获得服务器的资源。

那么，如果减少重定向的次数，也就可以减少 HTTP 请求的发送次数，降低网络性能。😙

另外，服务器一方可能架设多台代理服务器，需要代理服务器于客户端进行通信，这时客户端重定向会增加代理服务器也增加 HTTP 请求，增加消息传递的次数。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E5%AE%9A%E5%90%91.png)

因此**我们可以将重定向的工作交由代理服务器完成，从而减少 HTTP 请求次数**。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%91.png)

而且可以给代理服务器设置重定向的规则，进一步减少消息传递次数。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E5%AE%9A%E5%90%912.png)

```ad-example
* 301 表示资源永久重定向到另一个 URI 中
* 302 表示资源临时重定向到另一个 URI 中
* 303 表示资源重定向到其他资源
* 307 类似于302临时重定向，但是请求方法不能改变
* 308 类似于301永久重定向，但是请求方法不能改变
```

```ad-question
302 303 307 状态码的区别？
```

其中 `301` 和 `308` 响应码告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端将自动用 url2 替换 url1 去访问服务器的资源。

### 合并请求

如果把多个访问小文件的请求合并成一个大的请求，虽然传输的资源总数一样，但是减少请求，意味着可以**减少了重复发送的 HTTP 头部**。

另外由于 HTTP 1.1 是请求响应的模型，如果第一个发送的请求，未收到对应的响应，那么后续的请求就不会发送，导致队头阻塞。为了防止单个请求的队头阻塞，所以**浏览器一般会同时发起 5 - 6 个请求，每一个请求都是不同的 TCP 连接**，如果合并了请求，也就会**减少 TCP 连接的数量，因而省区了 TCP 握手和慢启动过程耗费的时间**。

接下来，具体看看合并请求的几种方式。

有的网页会含有很多小图片、小图标，有多少个小图片，客户端就要发起多少次请求。那么对于这些小图片，我们可以考虑使用 `CSS Image Sprites` 技术把它们合成一个大图片，这样浏览器就可以用一次请求获得一个大图片，然后再根据 CSS 数据把大图片切割成多张小图片。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/css%E7%B2%BE%E7%81%B5.png)

这种方式就是**通过将多个小图片合并成一个大图片来减少 HTTP 请求的次数，以减少 HTTP 请求的次数，从而减少网络的开销**。

除了将小图片合并成大图片的方式，还有服务端使用 `webpack` 等打包工具将 js、css 等资源合并打包成大文件，也是能达到类似的效果。

可以看到，**合并请求的方式就是合并资源，以一个大资源的请求替换多个小资源的请求**。

但是这样的合并请求会带来新的问题，**当大资源中的某一个小资源发生变化后，客户端必须重新下载整个完整的大资源文件**，这显然带来了额外的网络消耗。

### 延迟发送请求

不要一口气吃成大胖子，一般 HTML 里会含有很多 HTTP 的 URL，当前不需要的资源，我们没必要也获取过来，于是可以通过「**按需获取**」的方式，来减少第一时间的 HTTP 请求次数。

请求网页的时候，没必要把全部的资源都获取到位，只需要获取当前用户所看到的页面资源，当用户向下滑动的时候，在向服务器去获取接下来的资源，从而达到延迟发送的效果。

```ad-example
懒加载
```


## 如何减少 HTTP 响应的数据大小
---
对于 HTTP 的请求与响应，通过 HTTP 的响应数据大小会比较大，也就是服务器返回的资源比较大。

于是，我们可以考虑对响应资源进行压缩，从而减少响应资源的数据，从而提高网络资源传输的效率。

压缩的方式一般分为 2 种，分别是：

* **无损压缩**；
* **有损压缩**；

### 无损压缩

无损压缩是指资源经过压缩后，信息不被破坏，还能恢复成压缩前的原样，适合用在文本文件，程序可执行文件，程序源代码。

我们首先针对代码的语法规则进行压缩，把多余的换行符和空格进行去除。

接下来使用无损压缩，需要对原始资源建立统计模型，利用统计模型，将常出现的数据用比较短的二进制比特序表示，不常出现的数据用较长的比特序表示，一般使用 [霍夫曼编码](https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81) 算法。

[Gzip](https://zh.wikipedia.org/wiki/Gzip) 就是比较常见的无损压缩。客户端支持的压缩算法，会在 HTTP 请求中通过头部中的 `Accept-Encoding` 字段告诉服务器：

```
Accept-Encoding: gzip, deflate, br
```

服务器收到后，会从中选择一个服务器支持的或者合适的压缩算法，然后使用此压缩算法对响应资源进行压缩，最后通过响应头部中的 `Content-Encoding` 字段告诉客户端该资源使用的压缩算法。

```
Content-Encoding: gzip
```

```ad-question
title: Gzip无损压缩的原理
* [简单聊聊 GZIP 的压缩原理与日常应用 - 掘金](https://juejin.cn/post/6844903661575880717)
* [Gzip无损压缩的原理](https://www.cnblogs.com/junyuhuang/p/4138376.html)
```

### 有损压缩

与无损压缩相对的就是有损压缩，经过此方法压缩，解压的数据会与原始数据不同但是非常接近。

有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片。

可以通过 HTTP 请求头部中的 `Accept` 字段里的「 q 质量因子」，告诉服务器期望的资源质量。

```
Accept: audio/*; q=0.2, audio/basic
```

关于图片的压缩，目前压缩比较高的是 Google 推出的 **WebP 格式**，它与常见的 Png 格式图片的压缩比例对比如下图：

![来源于：https://isparta.github.io/compare-webp/index.html](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/http1.1%E4%BC%98%E5%8C%96/webp%E4%B8%8Epng.png)

可以发现，相同图片质量下，WebP 格式的图片大小都比 Png 格式的图片小，所以对于大量图片的网站，可以考虑使用 WebP 格式的图片，这将大幅度提升网络传输的性能。

关于音视频的压缩，音视频主要是动态的，每个帧都有时序的关系，通常时间连续的帧之间的变化是很小的。

比如，一个在看书的视频，画面通常只有人物的手和书桌上的书是会有变化的，而其他地方通常都是静态的，于是只需要在一个静态的关键帧，使用**增量数据**来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能。对于视频常见的编码格式有 H264、H265 等，音频常见的编码格式有 AAC、AC3。


